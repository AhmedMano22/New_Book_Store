"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sanitizeTypeNames = exports.sanitizeControllerTypeNames = exports.removeDefaultPlaceholders = exports.readFileInTree = exports.isNullOrUndefined = exports.interpolate = void 0;
const schematics_1 = require("@angular-devkit/schematics");
const ts = require("typescript");
function interpolate(text, ...params) {
    params.forEach((param, i) => {
        const pattern = new RegExp('{\\s*' + i + '\\s*}');
        text = text.replace(pattern, String(param));
    });
    return text;
}
exports.interpolate = interpolate;
function isNullOrUndefined(value) {
    return value === null || value === undefined;
}
exports.isNullOrUndefined = isNullOrUndefined;
function readFileInTree(tree, filePath) {
    const buffer = tree.read(filePath);
    if (isNullOrUndefined(buffer))
        throw new schematics_1.SchematicsException(interpolate("[File Not Found] There is no file at \"{0}\" path." /* Exception.FileNotFound */, filePath));
    const text = buffer.toString('utf-8');
    return ts.createSourceFile(filePath, text, ts.ScriptTarget.Latest, true);
}
exports.readFileInTree = readFileInTree;
function removeDefaultPlaceholders(oldParams) {
    const newParams = {};
    Object.entries(oldParams).forEach(([key, value]) => {
        newParams[key] = value === '__default' ? undefined : value;
    });
    return newParams;
}
exports.removeDefaultPlaceholders = removeDefaultPlaceholders;
const sanitizeTypeNameRegExp = /\+/g;
const sanitizeTypeName = (name) => name.replace(sanitizeTypeNameRegExp, '_');
function sanitizeControllerTypeNames(controllers) {
    Object.values(controllers || {}).forEach(controller => {
        controller.interfaces?.forEach(i => {
            i.methods?.forEach(m => {
                m.returnValue.type = sanitizeTypeName(m.returnValue.type);
                m.returnValue.typeSimple = sanitizeTypeName(m.returnValue.typeSimple);
                m.parametersOnMethod?.forEach(p => {
                    p.type = sanitizeTypeName(p.type);
                    p.typeAsString = sanitizeTypeName(p.typeAsString);
                    p.typeSimple = sanitizeTypeName(p.typeSimple);
                });
            });
        });
        Object.values(controller.actions || {}).forEach(a => {
            a.returnValue.type = sanitizeTypeName(a.returnValue.type);
            a.returnValue.typeSimple = sanitizeTypeName(a.returnValue.typeSimple);
            a.parametersOnMethod?.forEach(p => {
                p.type = sanitizeTypeName(p.type);
                p.typeAsString = sanitizeTypeName(p.typeAsString);
                p.typeSimple = sanitizeTypeName(p.typeSimple);
            });
            a.parameters?.forEach(p => {
                p.type = sanitizeTypeName(p.type);
                p.typeSimple = sanitizeTypeName(p.typeSimple);
            });
        });
    });
    return controllers;
}
exports.sanitizeControllerTypeNames = sanitizeControllerTypeNames;
function sanitizeTypeNames(types) {
    // sanitize typeNames, type, and typeSimple on properties
    return Object.entries(types).reduce((acc, [key, value]) => {
        const sanitized = sanitizeTypeName(key);
        const properties = value.properties?.map(p => {
            const t = sanitizeTypeName(p.type);
            const t2 = sanitizeTypeName(p.typeSimple);
            return { ...p, type: t, typeSimple: t2 };
        }) || null;
        return { ...acc, [sanitized]: { ...value, properties } };
    }, {});
}
exports.sanitizeTypeNames = sanitizeTypeNames;
//# sourceMappingURL=common.js.map